import indexHtml from "./frontend/index.html"
import { analyzeWineImage, validateImageBase64, autoGenerateWineInfo, step1_findVivinoUrl, step2_extractBasicInfo, step3_enrichInfo, step4_searchImages, preStep_extractFromImage } from "./api/gemini"
import { testConnection, supabase } from "./db/supabase"
import { generateQueryEmbedding, generateWineEmbedding, generateWineEmbeddingText } from "./api/openai"
import type { Wine } from "./frontend/types"

const PORT = process.env.PORT || 3000

// Supabase Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
await testConnection()

Bun.serve({
  port: PORT,

  async fetch(req) {
    const url = new URL(req.url)

    // Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏÑúÎπô
    if (url.pathname.startsWith('/img/')) {
      const filePath = `./src/frontend${url.pathname}`
      const file = Bun.file(filePath)

      if (await file.exists()) {
        return new Response(file)
      }

      return new Response('Image not found', { status: 404 })
    }

    // 404 for unmatched routes
    return new Response('Not found', { status: 404 })
  },

  routes: {
    // Î©îÏù∏ ÌéòÏù¥ÏßÄ
    "/": indexHtml,

    // API: ÏôÄÏù∏ ÎùºÎ≤® Ïä§Ï∫î
    "/api/wines/scan": {
      POST: async (req) => {
        try {
          console.log('üì∏ Received wine scan request')

          const formData = await req.formData()
          const imageFile = formData.get('image') as File

          if (!imageFile) {
            return Response.json({
              success: false,
              error: 'Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§'
            }, { status: 400 })
          }

          // Ïù¥ÎØ∏ÏßÄÎ•º Base64Î°ú Î≥ÄÌôò
          const imageBuffer = await imageFile.arrayBuffer()
          const imageBase64 = Buffer.from(imageBuffer).toString('base64')

          // Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
          if (!validateImageBase64(imageBase64)) {
            return Response.json({
              success: false,
              error: 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïù¥ÎØ∏ÏßÄ ÌòïÏãùÏûÖÎãàÎã§'
            }, { status: 400 })
          }

          console.log('üìä Image size:', imageFile.size, 'bytes')

          // Gemini APIÎ°ú Î∂ÑÏÑù (2Îã®Í≥Ñ: Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù + Ïõπ Í≤ÄÏÉâ)
          const wineInfo = await analyzeWineImage(imageBase64)

          return Response.json({
            success: true,
            data: wineInfo
          })

        } catch (error: any) {
          console.error('‚ùå Scan error:', error)
          return Response.json({
            success: false,
            error: error.message || 'ÏôÄÏù∏ Î∂ÑÏÑùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§'
          }, { status: 500 })
        }
      }
    },

    // API: ÏôÄÏù∏ ÏûêÎèô ÏÉùÏÑ± (ÌÜµÌï© - Í∏∞Ï°¥ Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
    "/api/wines/auto-generate": {
      POST: async (req) => {
        try {
          console.log('ü§ñ Received auto-generate request')

          const body = await req.json()
          const { title, winery } = body

          // Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
          if (!title) {
            return Response.json({
              success: false,
              error: 'ÏôÄÏù∏Î™ÖÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî'
            }, { status: 400 })
          }

          console.log(`üìù Input: ${title}${winery ? ` - ${winery}` : ''}`)

          // Gemini APIÎ°ú ÏûêÎèô ÏÉùÏÑ± (ÏôÄÏù¥ÎÑàÎ¶¨Îäî ÏÑ†ÌÉùÏÇ¨Ìï≠)
          const wineInfo = await autoGenerateWineInfo(title, winery)

          return Response.json({
            success: true,
            data: wineInfo
          })

        } catch (error: any) {
          console.error('‚ùå Auto-generate error:', error)
          return Response.json({
            success: false,
            error: error.message || 'ÏûêÎèô ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§'
          }, { status: 500 })
        }
      }
    },

    // API: Step 1 - Google SearchÎ°ú Vivino URL Ï∞æÍ∏∞
    "/api/wines/auto-generate/step1": {
      POST: async (req) => {
        try {
          console.log('üîç Step 1: Finding Vivino URL')

          const body = await req.json()
          const { title, winery } = body

          if (!title) {
            return Response.json({
              success: false,
              error: 'ÏôÄÏù∏Î™ÖÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî'
            }, { status: 400 })
          }

          const result = await step1_findVivinoUrl(title, winery)

          return Response.json({
            success: true,
            data: result
          })

        } catch (error: any) {
          console.error('‚ùå Step 1 error:', error)
          return Response.json({
            success: false,
            error: error.message || 'Vivino URL Í≤ÄÏÉâ Ïã§Ìå®'
          }, { status: 500 })
        }
      }
    },

    // API: Step 2 - VivinoÏóêÏÑú Í∏∞Î≥∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú
    "/api/wines/auto-generate/step2": {
      POST: async (req) => {
        try {
          console.log('üìÑ Step 2: Extracting basic info from Vivino')

          const body = await req.json()
          const { vivinoUrl } = body

          if (!vivinoUrl) {
            return Response.json({
              success: false,
              error: 'vivinoUrlÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî'
            }, { status: 400 })
          }

          const result = await step2_extractBasicInfo(vivinoUrl)

          return Response.json({
            success: true,
            data: result
          })

        } catch (error: any) {
          console.error('‚ùå Step 2 error:', error)
          return Response.json({
            success: false,
            error: error.message || 'Vivino Í∏∞Î≥∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú Ïã§Ìå®'
          }, { status: 500 })
        }
      }
    },

    // API: Step 3 - GroundingÏúºÎ°ú Ï∂îÍ∞Ä Ï†ïÎ≥¥ ÏàòÏßë
    "/api/wines/auto-generate/step3": {
      POST: async (req) => {
        try {
          console.log('üåê Step 3: Enriching with grounding search')

          const body = await req.json()
          const { basicInfo } = body

          if (!basicInfo || !basicInfo.title || !basicInfo.winery) {
            return Response.json({
              success: false,
              error: 'basicInfoÍ∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§'
            }, { status: 400 })
          }

          const result = await step3_enrichInfo(basicInfo)

          return Response.json({
            success: true,
            data: result
          })

        } catch (error: any) {
          console.error('‚ùå Step 3 error:', error)
          return Response.json({
            success: false,
            error: error.message || 'Ï∂îÍ∞Ä Ï†ïÎ≥¥ ÏàòÏßë Ïã§Ìå®'
          }, { status: 500 })
        }
      }
    },

    "/api/wines/auto-generate/step4": {
      POST: async (req) => {
        try {
          console.log('üñºÔ∏è  Step 4: Searching wine images')

          const body = await req.json()
          const { title, winery } = body

          if (!title) {
            return Response.json({
              success: false,
              error: 'ÏôÄÏù∏Î™ÖÏù¥ ÌïÑÏöîÌï©ÎãàÎã§'
            }, { status: 400 })
          }

          const imageUrls = await step4_searchImages(title, winery)

          return Response.json({
            success: true,
            data: { imageUrls }
          })

        } catch (error: any) {
          console.error('‚ùå Step 4 error:', error)
          return Response.json({
            success: false,
            error: error.message || 'Ïù¥ÎØ∏ÏßÄ Í≤ÄÏÉâ Ïã§Ìå®'
          }, { status: 500 })
        }
      }
    },

    // API: Pre-Step - ÏÇ¨ÏßÑÏóêÏÑú ÏôÄÏù∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú
    "/api/wines/auto-generate/prestep": {
      POST: async (req) => {
        try {
          console.log('üì∏ Pre-Step: Extracting wine info from photo')

          const formData = await req.formData()
          const imageFile = formData.get('image') as File

          if (!imageFile) {
            return Response.json({
              success: false,
              error: 'Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§'
            }, { status: 400 })
          }

          // Ïù¥ÎØ∏ÏßÄÎ•º Base64Î°ú Î≥ÄÌôò
          const imageBuffer = await imageFile.arrayBuffer()
          const imageBase64 = Buffer.from(imageBuffer).toString('base64')

          // Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
          if (!validateImageBase64(imageBase64)) {
            return Response.json({
              success: false,
              error: 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïù¥ÎØ∏ÏßÄ ÌòïÏãùÏûÖÎãàÎã§'
            }, { status: 400 })
          }

          // Pre-Step Ïã§Ìñâ
          const result = await preStep_extractFromImage(imageBase64)

          return Response.json({
            success: true,
            data: result
          })

        } catch (error: any) {
          console.error('‚ùå Pre-Step error:', error)
          return Response.json({
            success: false,
            error: error.message || 'ÏÇ¨ÏßÑ Î∂ÑÏÑù Ïã§Ìå®'
          }, { status: 500 })
        }
      }
    },

    // API: ÏôÄÏù∏ Ï∂îÍ∞Ä (Create Wine with Auto-Embedding)
    "/api/wines": {
      POST: async (req) => {
        try {
          console.log('üç∑ Creating new wine with auto-embedding...')

          const wine = await req.json()

          // 1. Insert wine into database
          const { data: newWine, error: insertError } = await supabase
            .from('wines')
            .insert(wine)
            .select()
            .single()

          if (insertError) {
            throw new Error(`Failed to insert wine: ${insertError.message}`)
          }

          console.log(`‚úÖ Wine created (ID: ${newWine.id})`)

          // 2. Generate and save embedding
          try {
            const embedding = await generateWineEmbedding(newWine)

            const { error: embedError } = await (supabase
              .from('wine_embeddings')
              .insert({
                wine_id: newWine.id,
                embedding: embedding,
                metadata: {
                  title: newWine.title,
                  winery: newWine.winery,
                  type: newWine.type,
                  vintage: newWine.vintage
                }
              }) as any)

            if (embedError) {
              console.error('‚ö†Ô∏è  Failed to generate embedding:', embedError.message)
              // Don't fail the request if embedding fails
            } else {
              console.log(`‚úÖ Embedding generated for wine ${newWine.id}`)
            }
          } catch (embedError: any) {
            console.error('‚ö†Ô∏è  Embedding generation error:', embedError.message)
            // Don't fail the request if embedding fails
          }

          return Response.json({
            success: true,
            data: newWine
          })

        } catch (error: any) {
          console.error('‚ùå Wine creation error:', error)
          return Response.json({
            success: false,
            error: error.message || 'ÏôÄÏù∏ Ï∂îÍ∞ÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§'
          }, { status: 500 })
        }
      },

      // Update Wine
      PUT: async (req) => {
        try {
          const url = new URL(req.url)
          const id = url.searchParams.get('id')

          if (!id) {
            return Response.json({
              success: false,
              error: 'Wine ID is required'
            }, { status: 400 })
          }

          console.log(`üîÑ Updating wine ${id} with auto-embedding...`)

          const wine = await req.json()

          // 1. Update wine in database
          const { data: updatedWine, error: updateError } = await supabase
            .from('wines')
            .update(wine)
            .eq('id', id)
            .select()
            .single()

          if (updateError) {
            throw new Error(`Failed to update wine: ${updateError.message}`)
          }

          console.log(`‚úÖ Wine ${id} updated`)

          // 2. Regenerate embedding
          try {
            const embedding = await generateWineEmbedding(updatedWine)

            const { error: embedError } = await (supabase
              .from('wine_embeddings')
              .upsert({
                wine_id: updatedWine.id,
                embedding: embedding,
                metadata: {
                  title: updatedWine.title,
                  winery: updatedWine.winery,
                  type: updatedWine.type,
                  vintage: updatedWine.vintage
                }
              }) as any)

            if (embedError) {
              console.error('‚ö†Ô∏è  Failed to regenerate embedding:', embedError.message)
            } else {
              console.log(`‚úÖ Embedding regenerated for wine ${id}`)
            }
          } catch (embedError: any) {
            console.error('‚ö†Ô∏è  Embedding regeneration error:', embedError.message)
          }

          return Response.json({
            success: true,
            data: updatedWine
          })

        } catch (error: any) {
          console.error('‚ùå Wine update error:', error)
          return Response.json({
            success: false,
            error: error.message || 'ÏôÄÏù∏ ÏàòÏ†ïÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§'
          }, { status: 500 })
        }
      },

      // Delete Wine
      DELETE: async (req) => {
        try {
          const url = new URL(req.url)
          const id = url.searchParams.get('id')

          if (!id) {
            return Response.json({
              success: false,
              error: 'Wine ID is required'
            }, { status: 400 })
          }

          console.log(`üóëÔ∏è  Deleting wine ${id}...`)

          // Delete wine (CASCADE will auto-delete embedding)
          const { error: deleteError } = await supabase
            .from('wines')
            .delete()
            .eq('id', id)

          if (deleteError) {
            throw new Error(`Failed to delete wine: ${deleteError.message}`)
          }

          console.log(`‚úÖ Wine ${id} deleted (embedding auto-deleted via CASCADE)`)

          return Response.json({
            success: true,
            data: { id: parseInt(id) }
          })

        } catch (error: any) {
          console.error('‚ùå Wine deletion error:', error)
          return Response.json({
            success: false,
            error: error.message || 'ÏôÄÏù∏ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§'
          }, { status: 500 })
        }
      }
    },

    // API: ÏãúÎß®Ìã± Í≤ÄÏÉâ (Semantic Search with RAG)
    "/api/search/semantic": {
      POST: async (req) => {
        try {
          console.log('üîç Semantic search request received')

          const body = await req.json()
          const { query, limit = 20 } = body

          if (!query || typeof query !== 'string') {
            return Response.json({
              success: false,
              error: 'Í≤ÄÏÉâÏñ¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî'
            }, { status: 400 })
          }

          console.log(`üìù Query: "${query}", Limit: ${limit}`)

          // 1. Generate query embedding
          const queryEmbedding = await generateQueryEmbedding(query)
          console.log(`‚úÖ Query embedding generated (${queryEmbedding.length} dimensions)`)

          // 2. Perform cosine similarity search using pgvector
          // @ts-ignore - Supabase RPC type issue
          const { data: results, error } = await supabase.rpc('match_wines', {
            query_embedding: queryEmbedding,
            match_threshold: 0.5,  // Minimum similarity threshold
            match_count: limit
          })

          if (error) {
            console.error('‚ùå Semantic search error:', error)
            throw new Error(`Database search failed: ${error.message}`)
          }

          console.log(`‚úÖ Found ${(results as any[])?.length || 0} matching wines`)

          return Response.json({
            success: true,
            data: {
              wines: (results as any[]) || [],
              count: (results as any[])?.length || 0
            }
          })

        } catch (error: any) {
          console.error('‚ùå Semantic search error:', error)
          return Response.json({
            success: false,
            error: error.message || 'ÏãúÎß®Ìã± Í≤ÄÏÉâÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§'
          }, { status: 500 })
        }
      }
    },

    // API: ÏûÑÎ≤†Îî© ÏùºÍ¥Ñ Ïû¨ÏÉùÏÑ± (Batch Regenerate Embeddings)
    "/api/embeddings/regenerate": {
      POST: async (req) => {
        try {
          console.log('üîÑ Starting batch embedding regeneration...')

          // 1. Fetch all wines from database
          const { data: wines, error: fetchError } = await supabase
            .from('wines')
            .select('*')
            .order('id')

          if (fetchError) {
            throw new Error(`Failed to fetch wines: ${fetchError.message}`)
          }

          if (!wines || wines.length === 0) {
            return Response.json({
              success: true,
              message: 'No wines found in database',
              data: { processed: 0, failed: 0 }
            })
          }

          console.log(`üìä Processing ${wines.length} wines...`)

          // 2. Generate embeddings for each wine
          let processed = 0
          let failed = 0
          const errors: { wine_id: number; error: string }[] = []

          for (const wine of wines as Wine[]) {
            try {
              console.log(`[${processed + failed + 1}/${wines.length}] Processing wine ID ${wine.id}: ${wine.title}`)

              // Generate embedding text
              const embeddingText = generateWineEmbeddingText(wine)

              // Generate embedding vector
              const embedding = await generateWineEmbedding(wine)

              // Upsert to wine_embeddings table
              // @ts-ignore - Supabase type issue with wine_embeddings
              const { error: upsertError } = await supabase
                .from('wine_embeddings')
                .upsert({
                  wine_id: wine.id,
                  embedding: embedding,
                  metadata: {
                    title: wine.title,
                    winery: wine.winery,
                    type: wine.type,
                    vintage: wine.vintage,
                    embedding_text_length: embeddingText.length
                  },
                  updated_at: new Date().toISOString()
                }, {
                  onConflict: 'wine_id'
                })

              if (upsertError) {
                throw new Error(`Upsert failed: ${upsertError.message}`)
              }

              processed++
              console.log(`‚úÖ Wine ID ${wine.id} processed successfully`)

              // Add small delay to avoid rate limiting
              await new Promise(resolve => setTimeout(resolve, 100))

            } catch (error: any) {
              failed++
              const errorMsg = error.message || 'Unknown error'
              console.error(`‚ùå Failed to process wine ID ${wine.id}:`, errorMsg)
              errors.push({ wine_id: wine.id, error: errorMsg })
            }
          }

          console.log(`‚úÖ Batch regeneration complete: ${processed} processed, ${failed} failed`)

          return Response.json({
            success: true,
            message: `Processed ${processed} wines, ${failed} failed`,
            data: {
              total: wines.length,
              processed,
              failed,
              errors: errors.slice(0, 10)  // Return first 10 errors
            }
          })

        } catch (error: any) {
          console.error('‚ùå Batch regeneration error:', error)
          return Response.json({
            success: false,
            error: error.message || 'ÏûÑÎ≤†Îî© Ïû¨ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§'
          }, { status: 500 })
        }
      }
    },

    // Health check
    "/api/health": {
      GET: () => {
        return Response.json({
          status: 'ok',
          timestamp: new Date().toISOString(),
          services: {
            database: 'connected',
            gemini: 'configured',
            openai: process.env.OPENAI_API_KEY ? 'configured' : 'not configured'
          }
        })
      }
    }
  },

  development: {
    hmr: true,
    console: true,
  }
})

console.log(`
üç∑ Podoring WMS is running!
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  Local:   http://localhost:${PORT}
  Health:  http://localhost:${PORT}/api/health
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`)
